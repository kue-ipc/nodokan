// NodeのNICを操作するためのJavaScript

import {listToSnake, listToField} from "../utils/string_utils.civet"
import Network from "../models/network.civet"
import MessageStore from "../utils/message_store.civet"
import ipaddr from "ipaddr.js"

class NodeNic
  @NAMES = [
    "_destroy"
    "interface_type"
    "name"
    "network_id"
    "auth"
    "mac_address"
    "ipv4_config"
    "ipv4_address"
    "ipv6_conifg"
    "ipv6_address"
  ]

  @(@rootNode, {@messageStore = new MessageStore({})} = {})
    console.debug `NodeNic: ${@rootNode.id}`
    @id = @rootNode.id.match(/^node_nics_attributes_(\d+)$/)?.at(1)
    unless @id?
      console.warn "NodeNic element's id not match node_nics_attributes_*"
      return

    @prefixList = ["node", "nics_attributes", @id]

    @inputs = Object.fromEntries(
      NodeNic.NAMES.map (name) =>
        node := @getNode(name)
        return [name, null] unless node?

        init := {
          value: node.value.toString()
          checked: node.checked
          selectedIndex: node.selectedIndex
        }

        options :=
          if node.tagName is "SELECT"
            [...node.options]

        hidden :=
          if node.tagName is "INPUT" and node.type is "checkbox"
            [...document.getElementsByName(node.name)]
              .find (el) -> el.type is "hidden"

        [name, {node, init, options, hidden}]
    )
    @duidNode = document.getElementById("node_duid")
    @messagesNode = @getNode("messages")
    @messageTemplateNode = @getNode("message", "template")

    @inputs["_destroy"].node.addEventListener "change", (_e) =>
      @changeDestroy()
    @inputs["interface_type"].node.addEventListener "change", (_e) =>
      @changeInterfaceType()
    @inputs["network_id"].node.addEventListener "change", (_e) =>
      @changeNetwork()

    @inputs["auth"].node.addEventListener "change", (_e) =>
      @requireMacAddress()

    @inputs["ipv4_config"]?.node?.addEventListener "change", (e) =>
      @requireMacAddress()
      @adjustAddress("ipv4", e.target.value)
    @inputs["ipv6_config"]?.node.addEventListener "change", (e) =>
      @requireDuid()
      @adjustAddress("ipv6", e.target.value)

    @requireMacAddress()
    @requireDuid()

    @network = null
    // changeDestroyを呼び出すとすべての変更が呼び出される
    @changeDestroy()

  getNodeId(...names)
    listToSnake(...@prefixList, ...names)

  getNode(...names)
    document.getElementById(@getNodeId(...names))

  disableInputs(names, {excludes = []} = {})
    for name of names
      continue if excludes.includes(name)

      {node, hidden} := @inputs[name] || {}
      continue unless node?

      // チェックボックスはhiddenに現在の設定値を入れて固定化する
      if node.tagName is "INPUT" && node.type is "checkbox" && hidden?
        hidden.value = if node.checked then "1" else "0"

      node.disabled = true

  enableInputs(names, {excludes = []} = {})
    for name of names
      continue if excludes.includes(name)

      {node, hidden} := @inputs[name] || {}
      continue unless node?

      // チェックボックスはhiddenを0に戻す
      if node.tagName is "INPUT" and node.type is "checkbox"
        hidden.value = "0"

      node.disabled = false

  addMessage(message)
    messageNode := @messageTemplateNode.content.cloneNode(true)
    messageNode.querySelector(".message").textContent = message
    @messagesNode.appendChild(messageNode)

  clearMessages()
    while @messagesNode.firstChild
      @messagesNode.removeChild(@messagesNode.lastChild)

  adjustConfig(ip)
    // networkがなければ、何もしない
    return unless @network?

    {node, init, options} := @inputs[`${ip}_config"`] || {}
    return unless node?

    list := @network?[`${ip}_config_list`]

    selectedIndex := opitons.findIndex (el) -> el.selected
    disabledIndex := options.findInedx (el) -> el.value is "disabled"
    
    for el of options
      if list.includes(el.value)
        el.disabled = false
      else
        el.disabled = true

    node.selectedIndex =
      if selectedIndex is not disabledIndex and !options[selectedIndex].disbaled
        selectedIndex
      else if @checkInitInput("network_id")
        init.selectedIndex
      else
        (options.findIndex (el) -> !el.disabled) || disabledIndex

    @adjustAddress(ip)

  adjustAddress(ip)
    {node, init} := @inputs[`${ip}_address`] || {}
    return unless node?

    config := @inputs[`${ip}_config`]?.value || "disabled"

    node.placeholder = @messageStore.get(config, scope: "no_address",
      default: "")
    node.value =
      if checkInitInput("network_id") && checkInitInput(`${ip}_config`)
        init.value || ""
      else
        ""

    node.disabled = 
      if !@network?.current_user?.manageable or
           ["dynamic", "disabled", "mapped"].includes(config)
        node.disabled = true
      else
        node.disabled = false

  requireMacAddress()
    if @inputs["auth"].node.checked or
        @inputs["ipv4_config"]?.node?.value is "reserved"
      @inputs["mac_address"].node.required = true
      @addMessage(@messageStore.get("helps.require_mac"))
    else
      @inputs["mac_address"].node.required = false

  requireDuid()
    if @inputs["ipv6_config"]?.node?.value is "reserved"
      @duidNode.required = true
      @addMessage(@messageStore.get("helps.require_duid"))
    else
      @duidNode.required = false

  setInitInput(name)
    {node, init} := @inputs[name]
    return unless node?

    switch node.tagName
      "INPUT"
        if node.type is "checkbox"
          node.checked = init.checked
        else
          node.value = init.value
      "SELECT"
        node.selectedIndex = init.selectedIndex

  checkInitInput(name) ->
    {node, init} := @inputs[name]
    return true unless node?

    switch node.tagName
      "INPUT"
        if node.type is "checkbox"
          node.checked is init.checked
        else
          node.value is init.value
      "SELECT"
        node.selectedIndex is init.selectedIndex
      else
        false

  changeDestroy()
    if @inputs["_destroy"].node.checked
      @disableInputs(NodeNic.NAMES, excludes: ["_destroy"])
      return

    @enableInputs(["interface_type"])
    @changeInterfaceType()

  changeInterfaceType()
    unless @inputs["interface_type"].node.value
      @disableInputs(NodeNic.NAMES, excludes: ["_destroy", "interface_type"])
      return

    @enableInputs(["name", "network_id", "mac_address", "duid"])
    @changeNetwork()

  changeNetwork()
    @clearMessages()

    networkId := @inputs["network_id"].node.value
    @network = if networkId? then await Network.fetch(networkId) else null

    if @network
        // auth
        if @network.auth
          @addMessage(@messageStore.get("helps.auth_network"))
          if @checkInitInput("network_id")
            @setInitInput("auth")
          else
            @inputs["auth"].node.checked = true
          @enableInputs(["auth"])
        else
          @inputs["auth"].node.checked = false
          @disableInputs(["auth"])

        // note
        if @network.note
          @addMessage(@network.note)

        @enableInputs(["ipv4_config", "ipv6_config"])
    else if networkId?
      @setInitInput("auth")
      @setInitInput("ipv4_config")
      @setInitInput("ipv6_config")
      @disableInputs(["auth", "ipv4_config", "ipv6_config"])
      @addMessage(@messageStore.get("helps.unconfigurable"))
    else
      @inputs["auth"].node.checked = false
      @disableInputs(["auth", "ipv4_config", "ipv6_config"])
      @addMessage(@messageStore.get("helps.no_network"))

    @adjustConfig("ipv4")
    @adjustConfig("ipv6")
    @requireMacAddress()
    @requireDuid()

let messageStore

LOADED_ELEMENTS := new WeakSet()

export loadNodeFlags: (element?: Element) => void := (element) ->

export loadNodeNics: (element?: Element) => void := (element) ->
  return if element? and not element.id.includes("node_")

  unless messageStore?
    messagesNode := document.getElementById("node-nic-messages")
    if messagesNode?
      messages := JSON.parse(messagesNode.textContent)
      messageStore = new MessageStore(messages)

  for el of document.getElementsByClassName("node-nic-frame")
    if LOADED_ELEMENTS.has(el)
      console.warn `[node_nics] element is already loaded: ${el.id}`
      continue

    new NodeNic(el, {messageStore})
    LOADED_ELEMENTS.add(el)
