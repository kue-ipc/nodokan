import {Controller} from "@hotwired/stimulus"

// previous: 前の値が必要かどうか
// clear: 変更時にクリアまたは初期値に戻すかどうか
// per: 検索するアイテム数上限
// order: リストの順番

// name: モデルの名前 [必須]
// target: 対象となる属性 [必須]
// url: indexのJSONのパス [必須]
// parent: 親のモデルの名前
// parents: 親のモデルの名前のリスト
// inputList: 条件の参照となるinputのリスト
// requiredInput: 検索するときに入力が必須であるinput
// description: 説明があるかどうか
// locked: 変更不可になるもの
// required: 入力必須になるもの

// Index calss for controller#index API access with per, order, target, condition params
namespace Index
  export Name ::= string
  export Value ::= null | boolean | string | number
  export Entry ::= {[key: Name]: Value}
  export OrpderParams ::= {[key: Name]: "asc" | "desc"}
  export ConditionParams ::= {[key: Name]: Value}

class Index
  url: URL

  @(url: URL, {per:: number = 100, order:: Index.OrpderParams = {}} = {})
    @url = new URL(url) // clone
    params := @url.searchParams
    params.append("per", per.toString())
    for k, v in order when v?
      params.append(`order[${k}]`, v)

  createUrl({target:: Index.Name, condition:: Index.ConditionParams}): URL
    url := new URL(@url) // clone
    params := url.searchParams
    params.append("target", target)
    for k, v in condition when v?
      name := `condition[${k}]`
      value := switch v
        <? "string" then v
        <? "number" then v.toString()
        true then "1"
        false then "0"
      params.append(name, value) if value?
    url

  getList({target:: string, condition:: Index.ConditionParams}): Promise<Index.Entry[]>
    url := @createUrl({target, condition})
    response := await fetch(url)
    result := await response.json()
    data := result["data"]
    throw new Error("Invalid data format") unless data? and Array.isArray(data)

    // FIMXE: 型チェックしていない。型チェックが必要と思われる。
    data as Index.Entry[]

// Connects to data-controller="datalist-candidate"
export default class DatalistCandidateController < Controller
  @targets = ["input", "datalist", "description"]

  @values = {
    url: String,
    previous: Boolean,
    clear: Boolean,
    per: {type: Number, per: 100},
    order: Object,

    // prerequisite: Boolean,
    // lockedList: Array,

    // name: String,

    // // target: String,
    // parent: {type:String, default: null},
    // parents: {type: Array, default: []},
    // order: {type:String, default: null},
    // inputList: {type: Array, default: []},
    // requiredInput: {type: String, default: null},
    // description: {type: Boolean, default: false},
    // clear: {type: Boolean, default: false},
    // locked: Boolean,
    // required: Boolean
  }

  declare readonly inputTargets: (HTMLInputElement | HTMLSelectElement)[]
  declare readonly datalistTarget: HTMLDataListElement
  declare readonly descriptionTarget: HTMLElement
  declare readonly hasDatalistTarget: boolean
  declare readonly hasDescriptionTarget: boolean

  declare readonly urlValue: string
  declare readonly previousValue: boolean
  declare readonly clearValue: boolean
  declare readonly perValue: number
  // not check type because of Object type
  declare readonly orderValue: Index.OrpderParams

  index?: Index

  connect(): void
    // create base url
    url := new URL(@urlValue, globalThis.location.href)
    @index = new Index(url, {per: @perValue, order: @orderValue})

  // abc[def][ghi] -> abc
  #getName(input: HTMLInputElement | HTMLSelectElement): string
    input.name.replace(/^\s*([^\[\]]+).*$/, "$1")

  #createCondition(inputs: (HTMLInputElement | HTMLSelectElement)[]): Index.ConditionParams
    condition: Index.ConditionParams := {}

    for input of inputs
      name := #getName(input)
      switch input
        <? HTMLInputElement
          switch input.type
            "checkbox"
              condition[name] = if input.checked then 1 else 0
            "radio"
              if input.checked
                condition[name] = input.value
            else
              condition[name] = input.value
        <? HTMLSelectElement
          condition[name] = input.value
    condition

  changeInput(): void
    // if @clearValue
    //   for input of @inputTargets
    //     switch input
    //       <? HTMLInputElement
    //         switch input.type
    //           "checkbox", "radio"
    //             input.checked = false
    //           else
    //             input.value = ""
    //       <? HTMLSelectElement
    //         input.selectedIndex = 0

    @updateDatalist()
    // @updateDescription()

  updateDatalist(): void
    inputs: (HTMLInputElement | HTMLSelectElement)[] := []
    for input of @inputTargets
      preInputs: (HTMLInputElement | HTMLSelectElement)[] := [...inputs]
      inputs.push(input)

      continue unless input <? HTMLInputElement
      continue unless input.type is in ["text", "search", "url", "tel", "email", "number", "range", "color"]
      continue unless input.list?

      async do
        if @index and input.list?
          target := #getName(input)
          list := await @index.getList({target, condition: #createCondition(preInputs)})
          newList := input.list.cloneNode(false)
          for entry of list
            option := document.createElement("option")
            option.textContent = entry[target]?.toString() ?? ""
            newList.appendChild(option)
          input.list.replaceWith(newList)



      // datalist := @datalistTargets.find (datalist) => datalist.id is input.attriib
      // switch input.type
      //   when "checkbox", "radio"
      //     console.log `${input.name} = ${input.checked}`
      //   else
      //     console.log `${input.name} = ${input.value}`

//  text, search, url, tel, email, date, month, week, time, datetime-local, number, range, color

    // Code to update the datalist based on input can be added here
    // console.log("Updating datalist from URL:", @urlValue)

  // updateDescription(): void
  //   if @hasDescriptionTarget
  //     // Code to update the description can be added here
  //     console.log("Updating description")
