import {Controller} from "@hotwired/stimulus"

// Index calss for controller#index API access with per, order, target, condition params
namespace Index
  export Name ::= string
  export Value ::= null | boolean | string | number
  export Entry ::= Record<Name, Value>
  export OrpderParams ::= Record<Name, "asc" | "desc">
  export ConditionParams ::= Record<Name, Value>

class Index
  url: URL

  @(url: URL, {per:: number = 100, order:: Index.OrpderParams = {}} = {})
    @url = new URL(url) // clone
    params := @url.searchParams
    params.append("per", per.toString())
    for k, v in order when v?
      params.append(`order[${k}]`, v)

  createUrl({target:: Index.Name, condition:: Index.ConditionParams}): URL
    url := new URL(@url) // clone
    params := url.searchParams
    params.append("target", target)
    for k, v in condition when v?
      name := `condition[${k}]`
      value := switch v
        <? "string" then v
        <? "number" then v.toString()
        true then "1"
        false then "0"
      params.append(name, value) if value?
    url

  getEntries({target:: string, condition:: Index.ConditionParams}): Promise<Index.Entry[]>
    url := @createUrl({target, condition})
    console.debug "fetch GET", url.toString()
    response := await fetch(url)
    result := await response.json()
    data := result["data"]
    throw new Error("Invalid data format") unless data? and Array.isArray(data)

    // FIMXE: 型チェックしていない。型チェックが必要と思われる。
    data as Index.Entry[]

// url: indexのJSONのパス [必須]
// per: 検索するアイテム数上限
// order: リストの順番
// previous: 前の値が必要かどうか
// clear: 変更時にクリアまたは初期値に戻すかどうか

// Connects to data-controller="datalist-candidate"
export default class DatalistCandidateController < Controller
  @targets = ["input", "datalist", "description"]

  @values = {
    url: String,
    per: {type: Number, default: 100},
    order: Object,
    previous: Boolean,
    clear: Boolean,
  }

  declare readonly inputTargets: (HTMLInputElement | HTMLSelectElement)[]
  declare readonly datalistTargets: HTMLDataListElement[]
  declare readonly descriptionTargets: HTMLElement[]

  declare readonly urlValue: string
  declare readonly perValue: number
  declare readonly orderValue: Index.OrpderParams // not check type because of Object type
  declare readonly previousValue: boolean
  declare readonly clearValue: boolean

  index?: Index
  entriesMap: Map<Index.Name, Index.Entry[]> = new Map()

  connect(): void
    url := new URL(@urlValue, globalThis.location.href)
    @index = new Index(url, {per: @perValue, order: @orderValue})

  // abc[def][ghi] -> abc
  #getName(input: HTMLInputElement | HTMLSelectElement): string
    input.name.replace(/^.*\[([^\]]+)\]$/, "$1")

  #getValue(input: HTMLInputElement | HTMLSelectElement): Index.Value
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox"
            input.checked
          "radio"
            if input.checked
              input.value
            else
              null
          else
            input.value
      <? HTMLSelectElement
        input.value
      else
        null

  #setValue(input: HTMLInputElement | HTMLSelectElement, value: Index.Value): void
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox"
            input.checked = value is true
          "radio"
            input.checked = input.value is value?toString()
          else
            input.value = value?toString() ?? ""
      <? HTMLSelectElement
        input.value = value?toString() ?? ""

  #clearValue(input: HTMLInputElement | HTMLSelectElement): void
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox", "radio"
            input.checked = false
          else
            input.value = ""
      <? HTMLSelectElement
        input.selectedIndex = 0

  #createCondition(inputs: (HTMLInputElement | HTMLSelectElement)[]): Index.ConditionParams
    condition: Index.ConditionParams := {}

    for input of inputs
      name := #getName(input)
      value := #getValue(input)
      condition[name] = value

    condition

  #getEntries(target: Index.Name, condition: Index.ConditionParams): Index.Entry[]
    throw new Error("this.index is not initialized") unless @index?

    key := `${target}:${JSON.stringify(condition)}`
    return @entriesMap.get(key) ?? [] if @entriesMap.has(key)

    // get entries from index API
    entries := await @index.getEntries({target, condition})
    @entriesMap.set(key, entries)
    entries

  #findeEntry(input: HTMLInputElement | HTMLSelectElement, entries: Index.Entry[]): Index.Entry?
    name := #getName(input)
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox"
            entries.find(&[name] is input.checked)
          "radio"
            if input.checked
              entries.find(&[name] is input.value)
          else
            entries.find(&[name]?.toString() is input.value)
      <? HTMLSelectElement
        entries.find(&[name]?.toString() is input.value)

  #updateInputStatus(input: HTMLInputElement, status: {disabled: boolean, "readonly": boolean, required: boolean}): void
    input.disabled = status.disabled
    input.readOnly = status.readonly
    input.required = status.required
    for each label of input.labels ?? [] when label?
      for [key, value] of Object.entries(status)
        if value
          label.classList.add(key)
        else
          label.classList.remove(key)


  #updateDatalist(input: HTMLInputElement, entries: Index.Entry[]): void
    return unless input.list?

    name := #getName(input)

    datalist := input.list.cloneNode(false)
    for entry of entries
      option := document.createElement("option")
      option.textContent = entry[name]?toString() ?? ""
      datalist.appendChild(option)
    input.list.replaceWith(datalist)

  #updateDescription(input: HTMLInputElement | HTMLSelectElement, entry: Index.Entry?): void
    describedby := input.getAttribute("aria-describedby")
    return unless describedby?

    description: string? := entry?description?toString()
    for element of @descriptionTargets when element.id is describedby
      element.textContent = description ?? ""

  checkInputs({target?:: HTMLElement}): void
    unless target <? HTMLInputElement or target <? HTMLSelectElement
      throw new Error("event target is not input or select element")

    #updateInputsAsyc(target)

  #updateInputsAsyc(changedInput: HTMLInputElement | HTMLSelectElement): Promise<void>
    // collected inputs
    inputs: (HTMLInputElement | HTMLSelectElement)[] := []
    // flags
    disabled .= false
    absent .= false
    locked .= false
    changed .= false
    required .= false

    for input of @inputTargets
      name := #getName(input)

      if input <? HTMLInputElement
        #updateInputStatus(input, {disabled: disabled, "readonly": locked,
          required: required and !disabled and !locked})

      #clearValue(input) if @clearValue and changed

      entries :=
        if absent
          [] as Index.Entry[]
        else
          await #getEntries(name, #createCondition(inputs))
      entry := #findeEntry(input, entries)
      if changed
        // overwrite value if locked
        #setValue(input, entries[0]?[name] ?? null) if locked

        #updateDatalist(input, entries) if input <? HTMLInputElement

      #updateDescription(input, entry)

      // collect inputs for next
      inputs.push(input)

      // update flags for next input
      // disable next input if previous is true and input is empty
      disabled = true if not disabled and @previousValue and input.value is ""
      // absent next input if no entry found
      absent = true if not absent and not entry?
      // lock next input if current entry is locked
      locked = true if not locked and entry?.locked
      // changed next inputs if current input is changed
      changed = true if not changed and input is changedInput
      // required next input if current entry is required
      required = true if not required and entry?.required

      console.debug "datalist-candidate:", {name, entry, disabled, absent, locked, changed, required}
