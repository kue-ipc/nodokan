import {Controller} from "@hotwired/stimulus"

// Index calss for controller#index API access with per, order, target, condition params
namespace Index
  export Name ::= string
  export Value ::= null | boolean | string | number
  export Entry ::= Record<Name, Value>
  export OrpderParams ::= Record<Name, "asc" | "desc">
  export ConditionParams ::= Record<Name, Value>

class Index
  url: URL

  @(url: URL, {per:: number = 100, order:: Index.OrpderParams = {}} = {})
    @url = new URL(url) // clone
    params := @url.searchParams
    params.append("per", per.toString())
    for k, v in order when v?
      params.append(`order[${k}]`, v)

  createUrl({target:: Index.Name, condition:: Index.ConditionParams}): URL
    url := new URL(@url) // clone
    params := url.searchParams
    params.append("target", target)
    for k, v in condition when v?
      name := `condition[${k}]`
      value := switch v
        <? "string" then v
        <? "number" then v.toString()
        true then "1"
        false then "0"
      params.append(name, value) if value?
    url

  getEntries({target:: string, condition:: Index.ConditionParams}): Promise<Index.Entry[]>
    url := @createUrl({target, condition})
    console.debug "fetch GET", url.toString()
    response := await fetch(url)
    result := await response.json()
    data := result["data"]
    throw new Error("Invalid data format") unless data? and Array.isArray(data)

    // FIMXE: 型チェックしていない。型チェックが必要と思われる。
    data as Index.Entry[]

// url: indexのJSONのパス [必須]
// previous: 前の値が必要かどうか
// clear: 変更時にクリアまたは初期値に戻すかどうか
// per: 検索するアイテム数上限
// order: リストの順番

// Connects to data-controller="datalist-candidate"
export default class DatalistCandidateController < Controller
  @targets = ["input", "datalist", "description"]

  @values = {
    url: String,
    per: {type: Number, default: 100},
    order: Object,
    clear: Boolean,
    previous: Boolean,
    locked: Object,
  }

  declare readonly inputTargets: (HTMLInputElement | HTMLSelectElement)[]
  declare readonly datalistTargets: HTMLDataListElement[]
  declare readonly descriptionTargets: HTMLElement[]

  declare readonly urlValue: string
  declare readonly perValue: number
  declare readonly orderValue: Index.OrpderParams // not check type because of Object type
  declare readonly clearValue: boolean
  declare readonly previousValue: boolean
  declare readonly lockedValue: Record<Index.Name, Index.Value[]> // not check type because of Object type


  index?: Index
  entriesMap: Map<Index.Name, Index.Entry[]> = new Map()

  connect(): void
    url := new URL(@urlValue, globalThis.location.href)
    @index = new Index(url, {per: @perValue, order: @orderValue})

  // abc[def][ghi] -> abc
  #getName(input: HTMLInputElement | HTMLSelectElement): string
    input.name.replace(/^.*\[([^\]]+)\]$/, "$1")

  #getValue(input: HTMLInputElement | HTMLSelectElement): Index.Value
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox"
            if input.checked then 1 else 0
          "radio"
            if input.checked
              input.value
            else
              null
          else
            input.value
      <? HTMLSelectElement
        input.value
      else
        null

  #clearValue(input: HTMLInputElement | HTMLSelectElement): void
    switch input
      <? HTMLInputElement
        switch input.type
          "checkbox", "radio"
            input.checked = false
          else
            input.value = ""
      <? HTMLSelectElement
        input.selectedIndex = 0


  #createCondition(inputs: (HTMLInputElement | HTMLSelectElement)[]): Index.ConditionParams
    condition: Index.ConditionParams := {}

    for input of inputs
      name := #getName(input)
      value := #getValue(input)
      condition[name] = value

    condition

  #getEntries(target: Index.Name, condition: Index.ConditionParams): Index.Entry[]
    throw new Error("this.index is not initialized") unless @index?

    key := `${target}:${JSON.stringify(condition)}`
    return @entriesMap.get(key) ?? [] if @entriesMap.has(key)

    // get entries from index API
    entries := await @index.getEntries({target, condition})
    @entriesMap.set(key, entries)
    entries

  #updateDatalist(input: HTMLInputElement, entries: Index.Entry[]): void
    return unless input.list?

    name := #getName(input)

    datalist := input.list.cloneNode(false)
    for entry of entries
      option := document.createElement("option")
      option.textContent = entry[name]?toString() ?? ""
      datalist.appendChild(option)
    input.list.replaceWith(datalist)

  #updateDescription(input: HTMLInputElement | HTMLSelectElement, entries: Index.Entry[]): void
    describedby := input.getAttribute("aria-describedby")
    return unless describedby?

    name := #getName(input)

    // FIXME: entryのvalueがstring以外の場合は、文字列との比較になるため、うまく動かない。
    description: string? := entries.find(&[name] is input.value)?description?toString()
    for element of @descriptionTargets when element.id is describedby
      element.textContent = description ?? ""

  checkInputs({target: changedInput?:: HTMLElement}): void
    throw new Error("DatalistCandidateController: index is not initialized") unless @index?
    unless changedInput <? HTMLInputElement or changedInput <? HTMLSelectElement
      throw new Error("DatalistCandidateController: event target is not input or select element")

    inputs: (HTMLInputElement | HTMLSelectElement)[] := []
    // flags
    disabled .= false
    locked .= false
    changed .= false

    for input of @inputTargets
      name := #getName(input)
      preInputs: (HTMLInputElement | HTMLSelectElement)[] := [...inputs]
      inputs.push(input)

      // set disabled or locked state
      input.disabled = disabled or locked
      // need update if previous changed
      needUpdate := changed

      // update flags for next input
      // disable next input if previous is true and input is empty
      disabled = true if not disabled and @previousValue and input.value is ""
      // lock next input if params.locked includes current value
      locked = true if not locked and @lockedValue[name]? and input.value in @lockedValue[name]
      // changed next inputs if current input is changed
      changed = true if not changed and input is changedInput

      #clearValue(input) if needUpdate and @clearValue

      async do
        entries := await #getEntries(name, #createCondition(preInputs))
        #updateDatalist(input, entries) if needUpdate and input <? HTMLInputElement
        #updateDescription(input, entries) if needUpdate
