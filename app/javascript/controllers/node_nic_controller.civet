import {Controller} from "@hotwired/stimulus"
import {arrayDifference} from "../utils/set_utils.civet"
import Network from "../models/network.civet"
import {capitalize} from "../utils/string_utils.civet"

import MessageStore from "../utils/message_store.civet"

// TODO: 全体で管理するようなものに変えるべきかと
let messageStore: MessageStore? = undefined

getMessageStore := ->
  return messageStore if messageStore?

  messagesNode := document.getElementById("node-nic-messages")
  if messagesNode?
    messages := JSON.parse(messagesNode.textContent || "{}")
    messageStore = new MessageStore(messages)
  messageStore

// Connects to data-controller="node-nic"
export default class NodeNicController < Controller<HTMLElement>
  @names := [
    "destroy"
    "locked"
    "interfaceType"
    "name"
    "networkId"
    "macAddress"
    "auth"
    "ipv4Config"
    "ipv4Address"
    "ipv6Config"
    "ipv6Address"
  ] as const

  @targets := [...@names, "messages", "messageTemplate", "message"]

  // TODO: 下記のようにすべきだが、Civetがうまく動かない
  // https://stimulus.hotwired.dev/reference/using-typescript
  // declare readonly destroyTarget: HTMLInputElement // checkbox
  // declare readonly lockedTarget: HTMLInputElement // checkbox
  // declare readonly interfaceTypeTarget: HTMLSelectElement
  // declare readonly nameTarget: HTMLInputElement // text
  // declare readonly networkIdTarget: HTMLSelectElement
  // declare readonly macAddressTarget: HTMLInputElement // text
  // declare readonly authTarget: HTMLInputElement // checkbox
  // declare readonly ipv4ConfigTarget: HTMLSelectElement
  // declare readonly ipv4AddressTarget: HTMLInputElement // text
  // declare readonly ipv6ConfigTarget: HTMLSelectElement
  // declare readonly ipv6AddressTarget: HTMLInputElement // text
  // declare readonly messagesTarget: HTMLDivElement
  // declare readonly messageTemplateTarget: HTMLTemplateElement
  // declare readonly messageTargets: HTMLDivElement[]

  network: Network?
  messageStore: MessageStore?

  connect(): void
    @messageStore = getMessageStore()
    @change()

  change(_event?: Event): Promise<void>
    if @destroyTarget.checked
      @disableInputs(arrayDifference(NodeNicController.names, ["destroy"]))
      return

    @enableInputs(["interfaceType"])

    unless @interfaceTypeTarget.value
      @disableInputs(arrayDifference(NodeNicController.names,
        ["destroy", "interfaceType"]))
      return

    @enableInputs(["name", "networkId", "macAddress"])

    networkId := @networkIdTarget.value
    @network = if networkId then await Network.fetch(networkId) else undefined

    if @network
        // auth
        if @network.auth
          @addMessage("helps.auth_network")
          if @checkInitInput("network_id")
            @setInitInput("auth")
          else
            authNode.checked = true if authNode <? HTMLInputElement
          @enableInputs(["auth"])
        else
          authNode.checked = false if authNode <? HTMLInputElement
          @disableInputs(["auth"])

        // note
        if @network.note
          @addMessage("note", @network.note)

        @enableInputs(["ipv4_config", "ipv6_config"])
    else if networkId
      @setInitInput("auth")
      @setInitInput("ipv4_config")
      @setInitInput("ipv6_config")
      @disableInputs(["auth", "ipv4_config", "ipv6_config"])
      @addMessage("helps.unconfigurable")
    else
      authNode.checked = false if authNode <? HTMLInputElement
      @disableInputs(["auth", "ipv4_config", "ipv6_config"])
      @addMessage("helps.no_network")

    @adjustConfig("ipv4")
    @adjustConfig("ipv6")
    @requireMacAddress()
    @requireDuid()

  enableInputs(names: (typeof NodeNicController.names[number])[]): void
    for name of names
      continue unless @[`has${capitalize(name)}Target`]

      console.debug `enable: ${name}`
      target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement

      // チェックボックスはhiddenを0に戻す
      if target <? HTMLInputElement and target.type is "checkbox" and
        target.previousElementSibling <? HTMLInputElement and
        target.previousElementSibling.type is "hidden"
        target.previousElementSibling.value = "0"

      target.disabled = false

  disableInputs(names: (typeof NodeNicController.names[number])[]): void
    for name of names
      continue unless @[`has${capitalize(name)}Target`]

      console.debug `disable: ${name}`
      target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement

      // チェックボックスはhiddenに現在の設定値を入れて固定化する
      if target <? HTMLInputElement and target.type is "checkbox" and
        target.previousElementSibling <? HTMLInputElement and
        target.previousElementSibling.type is "hidden"
        target.previousElementSibling.value =
          if target.checked then "1" else "0"

      target.disabled = true

  addMessage(key: string, message?: string): void
    message = @messageStore?.get(key) unless message?
    unless message
      console.warn "[NodeNicController] no message"
      return

    id := @getNodeId("messages", key)
    currentMessageNode := document.getElementById(id)
    if currentMessageNode?
      currentMessageNode.textContent = message
    else
      clone := @messageTemplateNode.content.cloneNode(true)
      unless clone <? DocumentFragment or clone <? Element
        console.warn "[NodeNicController] no document frament nor element in template"
        return
      messageNode := clone.querySelector(".message")
      unless messageNode <? Element
        console.warn "[NodeNicController] no message element in template"
        return
      messageNode.id = id
      messageNode.textContent = message
      @messagesNode.appendChild(clone)
  
  removeMessage(key: string): void
    id := @getNodeId("messages", key)
    messageNode := document.getElementById(id)
    if messageNode?
      @messagesNode.removeChild(messageNode)

  clearMessages(): void
    while @messagesNode.firstChild
      last := @messagesNode.lastChild
      @messagesNode.removeChild(last) if last?

  setInitInput(name: NodeNic.Name): void
    input := @inputMap.get(name)
    return unless input?

    {node, init} := input

    switch node
      <? HTMLInputElement
        if node.type is "checkbox"
          node.checked = init.checked || false
        else
          node.value = init.value || ""
      <? HTMLSelectElement
        node.selectedIndex = init.selectedIndex || -1

  checkInitInput(name: NodeNic.Name): boolean
    input := @inputMap.get(name)
    return false unless input?
    {node, init} := input

    switch node
      <? HTMLInputElement
        if node.type is "checkbox"
          node.checked is init.checked
        else
          node.value is init.value
      <? HTMLSelectElement
        node.selectedIndex is init.selectedIndex
      else
        false

  adjustConfig(ip: "ipv4" | "ipv6"): void
    // networkがなければ、何もしない
    return unless @network?

    input := @inputMap.get(`${ip}_config`)
    return unless input?
    {node, init, options} := input
    unless node <? HTMLSelectElement
      console.warn `[NodeNicController] not selet element for ${ip}_config`
      return
    unless options?
      console.warn `[NodeNicController] no options for ${ip}_config`
      return

    list := @network?[`${ip}_config_list`]
    for el of options
      if list.includes(el.value)
        el.disabled = false
      else
        el.disabled = true

    selectedOption := node.selectedOptions.item(0)    

    if @checkInitInput("network_id")
      node.selectedIndex = init.selectedIndex || -1
    else if selectedOption !<? HTMLOptionElement or
        selectedOption.disabled or
        selectedOption.value is "disabled"
      node.selectedIndex = 
        (options.findIndex (el) -> !el.disabled) ||
        (options.findIndex (el) -> el.value is "disabled") ||
        -1

    @adjustAddress(ip)

  adjustAddress(ip: "ipv4" | "ipv6"): void
    input := @inputMap.get(`${ip}_address`)
    return unless input?
    {node, init} := input
    unless node <? HTMLInputElement
      console.warn `[NodeNicController] not input element for ${ip}_config`
      return

    config := @inputMap.get(`${ip}_config`)?.node.value || "disabled"

    node.placeholder =
      @messageStore.get(config, scope: "no_address",default: "")
    node.value =
      if @checkInitInput("network_id") && @checkInitInput(`${ip}_config`)
        init.value || ""
      else
        ""

    node.disabled =
      ["dynamic", "disabled", "mapped"].includes(config) or
        not @network?.current_user.manageable

  requireMacAddress(): void
    macAddressNode := @inputMap.get("mac_address")?.node
    unless macAddressNode <? HTMLInputElement
      console.warn "[NodeNicController] not input element for mac_address"
      return
    authNode := @inputMap.get("auth")?.node

    if (authNode <? HTMLInputElement and authNode.checked) or
        @inputMap.get("ipv4_config")?.node.value is "reserved"
      macAddressNode.required = true
      @addMessage("helps.require_mac")
    else
      macAddressNode.required = false
      @removeMessage("helps.require_mac")

  requireDuid(): void
    if @inputMap.get("ipv6_config")?.node?.value is "reserved"
      @duidNode.required = true
      @addMessage("helps.require_duid")
    else
      @duidNode.required = false
      @removeMessage("helps.require_duid")

