import {Controller} from "@hotwired/stimulus"
import {arrayDifference} from "../utils/set_utils.civet"
import Network from "../models/network.civet"
import {capitalize} from "../utils/string_utils.civet"

import MessageStore from "../utils/message_store.civet"

// TODO: 全体で管理するようなものに変えるべきかと
messageStore: MessageStore? .= undefined

getMessageStore := ->
  return messageStore if messageStore?

  messagesNode := document.getElementById("node-nic-messages")
  if messagesNode?
    messages := JSON.parse(messagesNode.textContent || "{}")
    messageStore = new MessageStore(messages)
  messageStore

// Connects to data-controller="node-nic"
export default class NodeNicController < Controller<HTMLElement>
  @names := [
    "locked"
    "interfaceType"
    "name"
    "networkId"
    "macAddress"
    "auth"
    "ipv4Config"
    "ipv4Address"
    "ipv6Config"
    "ipv6Address"
  ] as const

  @targets := [...@names, "destroy",
    "messagesRow", "messageTemplate", "messageCol"]

  // TODO: 下記のようにすべきだが、Civetがうまく動かない
  // https://stimulus.hotwired.dev/reference/using-typescript
  // declare readonly lockedTarget: HTMLInputElement // checkbox
  // declare readonly interfaceTypeTarget: HTMLSelectElement
  // declare readonly nameTarget: HTMLInputElement // text
  // declare readonly networkIdTarget: HTMLSelectElement
  // declare readonly macAddressTarget: HTMLInputElement // text
  // declare readonly authTarget: HTMLInputElement // checkbox
  // declare readonly ipv4ConfigTarget: HTMLSelectElement
  // declare readonly ipv4AddressTarget: HTMLInputElement // text
  // declare readonly ipv6ConfigTarget: HTMLSelectElement
  // declare readonly ipv6AddressTarget: HTMLInputElement // text

  // declare readonly destroyTarget: HTMLInputElement // checkbox

  // declare readonly messagesRowTarget: HTMLDivElement
  // declare readonly messageTemplateTarget: HTMLTemplateElement
  // declare readonly messageColTargets: HTMLDivElement[]

  network?: Network
  messageStore?: MessageStore
  initValue?: {
    locked: boolean
    interfaceType: number
    name: string
    networkId: number
    macAddress: string
    auth: boolean
    ipv4Config: number
    ipv4Address: string
    ipv6Config?: number
    ipv6Address?: string
  }

  connect(): void
    @messageStore = getMessageStore()
    @initValue = {
      locked: @lockedTarget.checked
      interfaceType: @interfaceTypeTarget.selectedIndex
      name: @nameTarget.value
      networkId: @networkIdTarget.selectedIndex
      macAddress: @macAddressTarget.value
      auth: @authTarget.checked
      ipv4Config: @ipv4ConfigTarget.selectedIndex
      ipv4Address: @ipv4AddressTarget.value
      ipv6Config: if @hasIpv6ConfigTarget then @ipv6ConfigTarget.selectedIndex
      ipv6Address: if @hasIpv6AddressTarget then @ipv6AddressTarget.value
    }
    @change()

  change(_event?: Event): Promise<void>
    if @destroyTarget.checked
      @disableInputs(NodeNicController.names)
      return

    @enableInputs(["interfaceType"])

    unless @interfaceTypeTarget.value
      @disableInputs(
        arrayDifference(NodeNicController.names, ["interfaceType"]))
      return

    @enableInputs(["name", "networkId", "macAddress"])

    networkId := @networkIdTarget.value
    @network = if networkId then await Network.fetch(networkId) else undefined

    if @network
        // auth
        if @network.auth
          @addMessage("helps.auth_network")
          if @checkInitInput("network_id")
            @setInitInput("auth")
          else
            @authTarget.checked = true
          @enableInputs(["auth"])
        else
          @authTarget.checked = false
          @disableInputs(["auth"])

        // note
        if @network.note
          @addMessage("note", @network.note)

        @enableInputs(["ipv4Config", "ipv6Config"])
    else if networkId
      @setInitInput("auth")
      @setInitInput("ipv4Config")
      @setInitInput("ipv6Config")
      @disableInputs(["auth", "ipv4Config", "ipv6Config"])
      @addMessage("helps.unconfigurable")
    else
      @authTarget.checked = false
      @disableInputs(["auth", "ipv4_config", "ipv6_config"])
      @addMessage("helps.no_network")

    @adjustConfig("ipv4")
    @adjustConfig("ipv6")
    @requireMacAddress()
    @requireDuid()

  enableInputs(names: string[]): void
    for name of names
      continue unless @[`has${capitalize(name)}Target`]

      console.debug `enable: ${name}`
      target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement

      // チェックボックスはhiddenを0に戻す
      if target <? HTMLInputElement and target.type is "checkbox" and
        target.previousElementSibling <? HTMLInputElement and
        target.previousElementSibling.type is "hidden"
        target.previousElementSibling.value = "0"

      target.disabled = false

  disableInputs(names: string[]): void
    for name of names
      continue unless @[`has${capitalize(name)}Target`]

      console.debug `disable: ${name}`
      target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement

      // チェックボックスはhiddenに現在の設定値を入れて固定化する
      if target <? HTMLInputElement and target.type is "checkbox" and
        target.previousElementSibling <? HTMLInputElement and
        target.previousElementSibling.type is "hidden"
        target.previousElementSibling.value =
          if target.checked then "1" else "0"

      target.disabled = true

  addMessage(key: string, message?: string): void
    message = @messageStore?.get(key) unless message?
    unless message
      console.warn "[NodeNicController] no message"
      return
    
    currentMessageCol :=
      @messageColTargets.find (el) -> el.dataset.messageKey is key
    if currentMessageCol
      currentMessageCol.textContent = message
      return

    clone := @messageTemplateTarget.content.cloneNode(true)
    unless clone <? DocumentFragment or clone <? HTMLElement
      console.warn "[NodeNicController] " +
        "no document frament nor html element in template"
      return
    messageCol := clone.querySelector(".message")
    unless messageCol <? HTMLElement
      console.warn "[NodeNicController] no message html element in template"
      return

    messageCol.dataset.nodeNicTarget = "messageRow"
    messageCol.dataset.messageKey = key
    messageCol.textContent = message
    @messagesRowTarget.appendChild(clone)
  
  removeMessage(key: string): void
    currentMessageCol :=
      @messageColTargets.find (el) -> el.dataset.messageKey is key

    if currentMessageCol?
      @messagesRowTarget.removeChild(currentMessageCol)

  clearMessages(): void
    while @messagesRowTarget.firstChild
      last := @messagesRowTarget.lastChild
      @messagesRowTarget.removeChild(last) if last?

  setInitInput(name: string): void
    return unless @[`has${capitalize(name)}Target`]

    target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement
    switch target
      <? HTMLInputElement
        if target.type is "checkbox"
          target.checked = @initValue[name] ?? false
        else
          target.value = @initValue[name] ?? ""
      <? HTMLSelectElement
        target.selectedIndex = @initValue[name] ?? -1

  checkInitInput(name: strnig): boolean
    return false unless @[`has${capitalize(name)}Target`]

    target := @[`${name}Target`] as HTMLInputElement | HTMLSelectElement
    switch target
      <? HTMLInputElement
        if target.type is "checkbox"
          target.checked is @initValue[name]
        else
          target.value is @initValue[name]
      <? HTMLSelectElement
        target.selectedIndex is @initValue[name]
      else
        false

  adjustConfig(ip: "ipv4" | "ipv6"): void
    // networkがなければ、何もしない
    return unless @network?
    return unless @[`has${capitalize(ip)}ConfigTarget`]

    target := @[`${ip}ConfigTarget`]
    unless target <? HTMLSelectElement
      console.warn `[NodeNicController] not select element for ${ip}Config`
      return

    list := @network[`${ip}_config_list`]
    for each el of target.options
      if list.includes(el.value)
        el.disabled = false
      else
        el.disabled = true

    selectedOption := target.selectedOptions[0]

    if @checkInitInput("network_id")
      target.selectedIndex = @initValue(`${ip}Config`) ?? -1
    else if selectedOption !<? HTMLOptionElement or
        selectedOption.disabled or
        selectedOption.value is "disabled"
      target.selectedIndex = 
        ([...target.options].findIndex (el) -> !el.disabled) ??
        ([...target.options].findIndex (el) -> el.value is "disabled") ??
        -1

    @adjustAddress(ip)

  adjustAddress(ip: "ipv4" | "ipv6"): void
    return unless @network?
    return unless @[`has${capitalize(ip)}AddressTarget`]

    target := @[`${ip}AddressTarget`]
    unless target <? HTMLInputElement
      console.warn `[NodeNicController] not input element for ${ip}Address`
      return

    config := @[`${ip}ConfigTarget`].value || "disabled"

    target.placeholder =
      @messageStore?.get(config, scope: "no_address", default: "") ?? ""
    target.value =
      if @checkInitInput("networkId") && @checkInitInput(`${ip}Cconfig`)
        @initValue?[`${ip}Address`] || ""
      else
        ""

    target.disabled =
      ["dynamic", "disabled", "mapped"].includes(config) or
        not @network?.current_user.manageable

  requireMacAddress(): void
    if @authTarget.checked or @ipv4ConfigTarget.value is "reserved"
      @macAddressTarget.required = true
      @addMessage("helps.require_mac")
    else
      @macAddressTarget.required = false
      @removeMessage("helps.require_mac")

  requireDuid(): void
    duidNode := document.getElementById("node_duid")
    unless duidNode <? HTMLInputElement
      console.warn "[NodeNicController] node duid not found"
      return

    if @hasIpv6ConfigTarget and @ipv6ConfigTarget.value is "reserved"
      duidNode.required = true
      @addMessage("helps.require_duid")
    else
      duidNode.required = false
      @removeMessage("helps.require_duid")

